<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mysql中in和exist的区别</title>
    <url>/2025562487.html</url>
    <content><![CDATA[<h3 id="in和exists的区别"><a href="#in和exists的区别" class="headerlink" title="in和exists的区别"></a><em>in和exists的区别</em></h3><h4 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h4><p>首先，查询中涉及到的两个表，一个user和一个order表，具体表的内容如下：</p>
<p>user表：<br><img src="/images/100001.png" alt="avatar"></p>
<p>order表：<br><img src="/images/100002.png" alt="avatar"></p>
<a id="more"></a>
<h4 id="in查询"><a href="#in查询" class="headerlink" title="in查询"></a>in查询</h4><p>确定给定的值是否与子查询或列表中的值相匹配。in在查询的时候，首先查询子查询的表，然后将内表和外表做一个笛卡尔积，然后按照条件进行筛选。所以相对内表比较小的时候，in的速度较快。</p>
<p>具体sql语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 SELECT</span><br><span class="line"> 2     *</span><br><span class="line"> 3 FROM</span><br><span class="line"> 4     `user`</span><br><span class="line"> 5 WHERE</span><br><span class="line"> 6     `user`.id IN (</span><br><span class="line"> 7         SELECT</span><br><span class="line"> 8             `order`.user_id</span><br><span class="line"> 9         FROM</span><br><span class="line">10             `order`</span><br><span class="line">11     )</span><br></pre></td></tr></table></figure>
<p>这条语句很简单，通过子查询查到的user_id 的数据，去匹配user表中的id然后得到结果。该语句执行结果如下：<br><img src="/images/100003.png" alt="avatar"></p>
<p>它的执行流程是什么样子的呢？让我们一起来看一下。</p>
<p>首先，在数据库内部，查询子查询，执行如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    `order`.user_id</span><br><span class="line">FROM</span><br><span class="line">    `order`</span><br></pre></td></tr></table></figure>
<p>执行完毕后，得到结果如下：<br><img src="100004.png" alt="avatar"><br>此时，将查询到的结果和原有的user表做一个笛卡尔积，结果如下：<br><img src="100005.png" alt="avatar"><br>此时，再根据我们的user.id IN order.user_id的条件，将结果进行筛选（既比较id列和user_id 列的值是否相等，将不相等的删除）。最后，得到两条符合条件的数据。<br><img src="100006.png" alt="avatar">
　　　　</p>
<h4 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h4><p>指定一个子查询，检测行的存在。遍历循环外表，然后看外表中的记录有没有和内表的数据一样的。匹配上就将结果放入结果集中。</p>
<p>具体sql语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 SELECT</span><br><span class="line"> 2     `user`.*</span><br><span class="line"> 3 FROM</span><br><span class="line"> 4     `user`</span><br><span class="line"> 5 WHERE</span><br><span class="line"> 6     EXISTS (</span><br><span class="line"> 7         SELECT</span><br><span class="line"> 8             `order`.user_id</span><br><span class="line"> 9         FROM</span><br><span class="line">10             `order`</span><br><span class="line">11         WHERE</span><br><span class="line">12             `user`.id = `order`.user_id</span><br><span class="line">13     )</span><br></pre></td></tr></table></figure>
<p>这条sql语句的执行结果和上面的in的执行结果是一样的:<br><img src="100007.png" alt="avatar"></p>
<p>但是，不一样的是它们的执行流程完全不一样：</p>
<p>使用exists关键字进行查询的时候，首先，我们先查询的不是子查询的内容，而是查我们的主查询的表，也就是说，我们先执行的sql语句是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT `user`.* FROM `user`</span><br></pre></td></tr></table></figure>
<p>得到的结果如下：<br><img src="100008.png" alt="avatar"><br>然后，根据表的每一条记录，执行以下语句，依次去判断where后面的条件是否成立：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXISTS (</span><br><span class="line">        SELECT</span><br><span class="line">            `order`.user_id</span><br><span class="line">        FROM</span><br><span class="line">            `order`</span><br><span class="line">        WHERE</span><br><span class="line">            `user`.id = `order`.user_id</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>如果成立则返回true不成立则返回false。如果返回的是true的话，则该行结果保留，如果返回的是false的话，则删除该行，最后将得到的结果返回。</p>
<h4 id="区别及应用场景"><a href="#区别及应用场景" class="headerlink" title="区别及应用场景"></a>区别及应用场景</h4><p>in 和 exists的区别: 如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in, 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。其实我们区分in和exists主要是造成了驱动顺序的改变(这是性能变化的关键)，如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 ，另外IN时不对NULL进行处理。</p>
<p>in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。一直以来认为exists比in效率高的说法是不准确的。</p>
<h4 id="not-in-和not-exists"><a href="#not-in-和not-exists" class="headerlink" title="not in 和not exists"></a>not in 和not exists</h4><p>如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL中exists和in的区别及使用场景</title>
    <url>/3887008439.html</url>
    <content><![CDATA[<p>MySQL中exists和in的区别及使用场景</p>
<p><em>转载自：<a href="https://www.cnblogs.com/xiaoxiong-kankan/p/7928153.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxiong-kankan/p/7928153.html</a></em></p>
<p>exists和in的使用方式：　　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#对B查询涉及id，使用索引，故B表效率高，可用大表 --&gt;外小内大</span><br><span class="line"></span><br><span class="line">select * from A where exists (select * from B where A.id=B.id);</span><br><span class="line"></span><br><span class="line">#对A查询涉及id，使用索引，故A表效率高，可用大表 --&gt;外大内小</span><br><span class="line"></span><br><span class="line">select * from A where A.id in (select id from B);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>1、exists是对外表做loop循环，每次loop循环再对内表（子查询）进行查询，那么因为对内表的查询使用的索引（内表效率高，故可用大表），而外表有多大都需要遍历，不可避免（尽量用小表），故内表大的使用exists，可加快效率；</p>
<p>2、in是把外表和内表做hash连接，先查询内表，再把内表结果与外表匹配，对外表使用索引（外表效率高，可用大表），而内表多大都需要查询，不可避免，故外表大的使用in，可加快效率。</p>
<p>3、如果用not in ，则是内外表都全表扫描，无索引，效率低，可考虑使用not exists，也可使用A left join B on A.id=B.id where B.id is null 进行优化。</p>
<p>此外，新近遇到的坑，mysql版本问题：</p>
<p>MySQL版本问题：5.6.5优化了子查询，引入物化子查询(针对where clause的subquery)，子查询物化将子查询结果存入临时表，确保子查询只执行一次，该表不记录重复数据且采用哈希索引查找;</p>
<p>而之前的版本则会把非相关子查询转化为相关子查询，导致效率低下（尤其是子查询是小表，外表是大表的情况下，效率变慢许多）。　　</p>
<p>　　<em>相关子查询：子查询依赖外层连接的返回值；</em></p>
<p>　　<em>非相关子查询：子查询不依赖外层连接的返回值；</em></p>
<p>　　子查询分两种，from语句（派生表）和where语句（子查询），派生表的效率要高一些，5.6的优化就是把where语句变成from语句。</p>
<p>　　本来是内表小，用的in，但是据说5.6之前的版本会把非相关子查询改为相关子查询，就是把in的语句改成了exists的，结果效率超低。</p>
<p>　　实验说明：派生表join比派生表的速度还要快。而使用in查询需要很多分钟还没有查出来。
　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#使用派生表 4.68秒</span><br><span class="line">SELECT id FROM la WHERE cardid IN (</span><br><span class="line">SELECT cardid FROM (</span><br><span class="line">select cardid from la group by cardid having count(1)&gt;50) a) ;</span><br><span class="line">#使用派生表的内连接 1.26秒</span><br><span class="line">SELECT id FROM la JOIN (</span><br><span class="line">select cardid from la group by cardid having count(1)&gt;50) a ON la.cardid=a.cardid;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title>电商系统中关于订单和库存的几个问题</title>
    <url>/3786447307.html</url>
    <content><![CDATA[<p><em>原创整理，转载请注明出处</em></p>
<h3 id="电商系统关于订单和库存的几个问题"><a href="#电商系统关于订单和库存的几个问题" class="headerlink" title="电商系统关于订单和库存的几个问题"></a>电商系统关于订单和库存的几个问题</h3><p>最近参加面试，被问及电商项目中如何处理并发情况下用户下单、减库存、事务一致性等问题。由于之前的项目类似于一个单体项目，对于高并发、高可用的的设计未有考虑，故面试问答很不流畅，有一定的相关概念，却没有一整套解决相关问题的流程。所以决定做个总结，以备后用。<br>总结起来有一下几个问题：</p>
<a id="more"></a>
<ol>
<li>系统是如何保证高并发下用户体验的？</li>
<li>扣减库存是下单扣减还是支付扣减？为什么？</li>
<li>对于库存的扣减，如何保证不超卖？</li>
<li>如何控制恶意库存占用？</li>
</ol>
<h4 id="问题一：系统是如何保证高并发下用户体验的？"><a href="#问题一：系统是如何保证高并发下用户体验的？" class="headerlink" title="问题一：系统是如何保证高并发下用户体验的？"></a>问题一：系统是如何保证高并发下用户体验的？</h4><p>首先我们来明确一个概念：并发。并发是什么？有人说并发就是两个或多个任务一起执行。在单核CPU中，执行任务的线程是交替获取cup时间切片的，由于切换并执行非常快，在外界看来，多个任务是一起执行的。实际上，它们是交替执行的。在虚拟机中，有个专门的内存区域叫程序计数器，它的目的就是记录每个线程执行的字节码的行号指示器，以应对线程切换执行时，切入执行时机的问题。与并发类似的概念是并行，它是真实地同步执行，所以只有在多核CPU中才会有并行地概念。<br>所以，对于高并发用户体验可用性问题，实际上就是系统地性能能达到什么样地程度问题。<br>这当中，数据库的访问性能往往又是系统的性能瓶颈。根据经验数据，用户在访问互联网时，超过90%的操作只是读取数据，提交、修改的数据不到10%。因此可以将内容相对固定、主要供用户浏览的页面生产缓存，而无需访问数据库。<br>对于静态内容（网页、图片、音频文件、脚本文件等）可以选择CDN（Content Delivery Network，内容分发网络）方式发布，从而通过专业内容发布服务提高网站访问速度。频繁修改的数据可以采用缓存的办法处理。</p>
<h4 id="问题二：扣减库存是下单扣减还是支付扣减？为什么？"><a href="#问题二：扣减库存是下单扣减还是支付扣减？为什么？" class="headerlink" title="问题二：扣减库存是下单扣减还是支付扣减？为什么？"></a>问题二：扣减库存是下单扣减还是支付扣减？为什么？</h4><p>核心思路是预锁库存，即下单时扣减，支付设置一个有效期，超过有效期释放库存。对于可能的恶意库存占用，限定用户在某个时间内的购买数量（或者达到一定数量提示其转到大客户购买处，单独处理）（PS：有位面试官牢牢抓住恶意库存占用问题问，最后聊得很尴尬，其实这本质上是产品得取舍问题，哪怕是支付后扣减，也有诸如支付了却提示库存不足得问题，这就要看产品根据实际情况做出权衡，技术上总归有实现思路的）。</p>
<p>摘抄他人总结的12306的实现思路<br>因为买火车票和购物不一样，购物可以付款后出库，但是买票这种，支付前就必须出库，因此，要将出库过程提前， 只有出库成功，才能生成订单，同样要引入redis库存</p>
<ol>
<li><p>先扣缓存中的库存，扣除成功后，然后才可以去扣mysql中的库存</p>
</li>
<li><p>如果扣除缓存中的库存失败，就会挡在外面，返回库存不足，这些请求不会穿刺到mysql中，挡住了大多数的请求压力。</p>
</li>
<li><p>redis库存会和mysql库存不一致，极端情况下是肯定有的，需要进行库存同步</p>
<p>3.1 当缓存库存比数据库库存多，那么就会出现，查询有票，但是就无法下单，下单的时候就说库存不足， 这样也不会超卖，当redis的库存多的那部分扣完了，就可以把请求全部当在外面了。 对于12306，有时候，查询的时候有票，但是下单的时候返回库存不足，然后重新查询发现还是有库存， 这种情况应该就是redis中库存和mysql中库存不一致造成的。</p>
<p>3.2 当缓存库存比数据库缓存少，那么不会出问题，只会出现有票，但是没有出售的情况，等完成库存同步一下， 明天又准确了。</p>
<p>3.3 当然，mysql扣除库存的部分，还需要在前面加入队列缓冲，避免请求过多，让应用程序或数据库崩溃。</p>
</li>
</ol>
<h4 id="问题三：对于库存的扣减，如何保证不超卖？"><a href="#问题三：对于库存的扣减，如何保证不超卖？" class="headerlink" title="问题三：对于库存的扣减，如何保证不超卖？"></a>问题三：对于库存的扣减，如何保证不超卖？</h4><p>方式一<br>可以对读操作加上显式锁（即在select …语句最后加上for update）这样一来用户1在进行读操作时用户2就需要排队等待了<br>但是问题来了，如果该商品很热门并发量很高那么效率就会大大的下降，怎么解决？<br>我们可以有条件有选择的在读操作上加锁，比如可以对库存做一个判断，当库存小于一个量时开始加锁，让购买者排队，这样一来就解决了超卖现象。<br>方式二<br>数据库表增加版本字段如version，每次修改时版本号+1<br>如果更新操作顺序执行，则数据的版本（version）依次递增，不会产生冲突。但是如果发生有不同的业务操作对同一版本的数据进行修改，那么，先提交的操作（图中B）会把数据version更新为2，当A在B之后提交更新时发现数据的version已经被修改了，那么A的更新操作会失败。<br>PDO update更新后，不但要验证返回状态是否为true,并且同时验证影响行数是否大于0<br>方式三 redis的队列来实现<br>将要促销的商品数量以队列的方式存入redis中，每当用户抢到一件促销商品则从队列中删除一个数据，确保商品不会超卖。这个操作起来很方便，而且效率极高，最终我们采取这种方式来实现</p>
<h4 id="问题四-如何控制恶意库存占用？"><a href="#问题四-如何控制恶意库存占用？" class="headerlink" title="问题四:如何控制恶意库存占用？"></a>问题四:如何控制恶意库存占用？</h4><p>首先，这个问题是否真实存在，或者说发生概率有多大？</p>
<p>产品设计有时候是一个博弈的过程，如果一个功能需要付出10的成本，却只覆盖了1的需求，这个功能是否真的需要投入开发？举个栗子，打车平台的车主入驻需要验证车主真实身份，在真实性安全性方面做好保障，某打车平台A在车主入驻的时候需要填写繁复的资料，比如验证身份证，举着身份证拍照等，结果导致只有5%的车主愿意走完整个验证流程，但实际上虚假的车主可能仅占1%，为了这1%的车主放弃了另外94%的服务者，是不是太亏了？</p>
<p>当然不是说问题小，就可以不去解决，但是可以考虑有没有侧面的低成本解决方案。</p>
<p>延续上面的例子，另外一个打车平台B在车主入驻的时候仅需要填写基础资料，那如何验证司机真实性呢？机智的B公司邀请司机绑定银行卡，载客收益到账是司机的最基本需求，而银行卡是与个人身份绑定的，已经经过银行验证过用户真实性的，较低的注册成本使得大部分的司机都愿意走完注册流程，开始使用B产品。</p>
<p>下面正面回答下问题，因为非电商行业，所以仅靠逻辑推理，如有错误，请及时沟通</p>
<p>1、反作弊策略。定义恶意下单的时间频次，IP或者UID信息，当操作行为触发反作弊策略后，可以对该商品的库存锁定机制做调整，对于某些运营活动的爆款需要设立白名单或者调整反作弊策略；</p>
<p>2、允许超卖。库存100件，允许超卖x%；</p>
<p>3、调整库存锁定/解锁策略，比如在下单后5min才触发库存锁定，或者下单后15min未支付则解除库存锁定；</p>
<p>5、当库存小于一定量时，界面设计上则显示库存紧张，以用户支付请求为节点，“先支付先得”。</p>
<p>参考：<br>电商产品如何防止恶意下单导致的库存被占用？<a href="https://www.pmcaff.com/discuss/index/1000000000162678?from=related&amp;pmc_param%5Bentry_id%5D=1000000000163080" target="_blank" rel="noopener">https://www.pmcaff.com/discuss/index/1000000000162678?from=related&amp;pmc_param%5Bentry_id%5D=1000000000163080</a><br>高并发电商平台设计 <a href="http://www.legendshop.cn/new_547.html" target="_blank" rel="noopener">http://www.legendshop.cn/new_547.html</a><br>用Redis轻松实现秒杀系统 <a href="https://blog.csdn.net/lida1234567/article/details/82866617" target="_blank" rel="noopener">https://blog.csdn.net/lida1234567/article/details/82866617</a><br>如何解决电商网站超卖现象 <a href="https://blog.csdn.net/u013521220/article/details/78839307" target="_blank" rel="noopener">https://blog.csdn.net/u013521220/article/details/78839307</a><br>关于电商库存扣除实现思路 <a href="http://www.fecmall.com/topic/648" target="_blank" rel="noopener">http://www.fecmall.com/topic/648</a></p>
]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis面试题：# 和 $ 的区别是什么</title>
    <url>/182044780.html</url>
    <content><![CDATA[<p><em>转载自：Mybatis中文网：<a href="http://www.mybatis.cn/" target="_blank" rel="noopener">http://www.mybatis.cn/</a></em></p>
<p>经常碰到这样的面试题目：#{}和${}的区别是什么？</p>
<p>正确的答案是：<strong>#{}是预编译处理，${}是字符串替换。</strong></p>
<p>备注：${}是插值，插值的新认识见： <a href="http://www.mybatis.cn/archives/653.html" target="_blank" rel="noopener">http://www.mybatis.cn/archives/653.html</a></p>
<a id="more"></a>
<ol>
<li><p>mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</p>
</li>
<li><p>mybatis在处理${}时，就是把${}替换成变量的值。</p>
</li>
<li><p>使用#{}可以有效的防止SQL注入，提高系统安全性。原因在于：预编译机制。预编译完成之后，SQL的结构已经固定，即便用户输入非法参数，也不会对SQL的结构产生影响，从而避免了潜在的安全风险。</p>
</li>
<li><p>预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。我们知道，SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作。而预编译机制则可以很好的防止SQL注入。</p>
</li>
</ol>
<p>补充1:</p>
<p>$符号一般用来当作占位符，常使用Linux脚本的人应该对此有更深的体会吧。例如：$1，$2等等表示输入参数的占位符。知道了这点就能很容易区分$和#，从而不容易记错了。</p>
<p>补充2：</p>
<p>万事洞明皆学问，对于mybatis与sql这两门技术而言，看似简单，但是深挖进去会发现里面的东西还是挺多的。要想成为一名合格的开发人员，需要不断的去学习，更需要不断的去思考。可以参考：<a href="http://www.mybatis.cn/category/mysql-mybatis/" target="_blank" rel="noopener">http://www.mybatis.cn/category/mysql-mybatis/</a> ，系统的学习sql和mybatis的东西，这是本站2019年计划出版的小册子，欢迎试读。</p>
<p>补充3：</p>
<p>有网友提问：既然${}会引起sql注入，为什么有了#{}还需要有${}呢？那其存在的意义是什么？<br>可以这么去理解：#{}主要用于预编译，而预编译的场景其实非常受限，而${}用于替换，很多场景会出现替换，而这种场景可不是预编译，例如：MyBatis XML配置对抗MyBatis注解的一大杀器：SQL片段，抽取可重用的SQL语句。</p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>Minor GC、Major GC和Full GC之间的区别</title>
    <url>/2196748335.html</url>
    <content><![CDATA[<p><em>原文链接： javacodegeeks 翻译： ImportNew.com - 光光头去打酱油</em></p>
<p><em>译文链接： <a href="http://www.importnew.com/15820.html" target="_blank" rel="noopener">http://www.importnew.com/15820.html</a></em></p>
<p>在 Plumbr 从事 GC 暂停检测相关功能的工作时，我被迫用自己的方式，通过大量文章、书籍和演讲来介绍我所做的工作。在整个过程中，经常对 Minor、Major、和 Full GC 事件的使用感到困惑。这也是我写这篇博客的原因，我希望能清楚地解释这其中的一些疑惑。<br>文章要求读者熟悉 JVM 内置的通用垃圾回收原则。堆内存划分为 Eden、Survivor 和 Tenured/Old 空间，代假设和其他不同的 GC 算法超出了本文讨论的范围。</p>
<a id="more"></a>
<h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。这一定义既清晰又易于理解。但是，当发生Minor GC事件的时候，有一些有趣的地方需要注意到：</p>
<p>当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以分配率越高，越频繁执行 Minor GC。<br>内存池被填满的时候，其中的内容全部会被复制，指针会从0开始跟踪空闲内存。Eden 和 Survivor 区进行了标记和复制操作，取代了经典的标记、扫描、压缩、清理操作。所以 Eden 和 Survivor 区不存在内存碎片。写指针总是停留在所使用内存池的顶部。<br>执行 Minor GC 操作时，不会影响到永久代。从永久代到年轻代的引用被当成 GC roots，从年轻代到永久代的引用在标记阶段被直接忽略掉。<br>质疑常规的认知，所有的 Minor GC 都会触发“全世界的暂停（stop-the-world）”，停止应用程序的线程。对于大部分应用程序，停顿导致的延迟都是可以忽略不计的。其中的真相就 是，大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。如果正好相反，Eden 区大部分新生对象不符合 GC 条件，Minor GC 执行时暂停的时间将会长很多。<br>所以 Minor GC 的情况就相当清楚了——每次 Minor GC 会清理年轻代的内存。</p>
<h3 id="Major-GC-vs-Full-GC"><a href="#Major-GC-vs-Full-GC" class="headerlink" title="Major GC vs Full GC"></a>Major GC vs Full GC</h3><p>大家应该注意到，目前，这些术语无论是在 JVM 规范还是在垃圾收集研究论文中都没有正式的定义。但是我们一看就知道这些在我们已经知道的基础之上做出的定义是正确的，Minor GC 清理年轻带内存应该被设计得简单：<br><strong>Major GC 是清理永久代。</strong></p>
<p>Full GC 是清理整个堆空间—包括年轻代和永久代。<br>很不幸，实际上它还有点复杂且令人困惑。首先，许多 Major GC 是由 Minor GC 触发的，所以很多情况下将这两种 GC 分离是不太可能的。另一方面，许多现代垃圾收集机制会清理部分永久代空间，所以使用“cleaning”一词只是部分正确。<br>这使得我们不用去关心到底是叫 Major GC 还是 Full GC，大家应该关注当前的 GC 是否停止了所有应用程序的线程，还是能够并发的处理而不用停掉应用程序的线程。<br>这种混乱甚至内置到 JVM 标准工具。</p>
<p>下面一个例子很好的解释了我的意思。让我们比较两个不同的工具 Concurrent Mark 和 Sweep collector (-XX:+UseConcMarkSweepGC)在 JVM 中运行时输出的跟踪记录。<br>第一次尝试通过 jstat 输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 my-precious: me$ jstat -gc -t 4235 1s</span><br><span class="line">12345678910111213 Time S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT    5.7 34048.0 34048.0  0.0   34048.0 272640.0 194699.7 1756416.0   181419.9  18304.0 17865.1 2688.0 2497.6      3    0.275   0      0.000    0.275 6.7 34048.0 34048.0 34048.0  0.0   272640.0 247555.4 1756416.0   263447.9  18816.0 18123.3 2688.0 2523.1      4    0.359   0      0.000    0.359 7.7 34048.0 34048.0  0.0   34048.0 272640.0 257729.3 1756416.0   345109.8  19072.0 18396.6 2688.0 2550.3      5    0.451   0      0.000    0.451 8.7 34048.0 34048.0 34048.0 34048.0 272640.0 272640.0 1756416.0  444982.5  19456.0 18681.3 2816.0 2575.8      7    0.550   0      0.000    0.550 9.7 34048.0 34048.0 34046.7  0.0   272640.0 16777.0  1756416.0   587906.3  20096.0 19235.1 2944.0 2631.8      8    0.720   0      0.000    0.72010.7 34048.0 34048.0  0.0   34046.2 272640.0 80171.6  1756416.0   664913.4  20352.0 19495.9 2944.0 2657.4      9    0.810   0      0.000    0.81011.7 34048.0 34048.0 34048.0  0.0   272640.0 129480.8 1756416.0   745100.2  20608.0 19704.5 2944.0 2678.4     10    0.896   0      0.000    0.89612.7 34048.0 34048.0  0.0   34046.6 272640.0 164070.7 1756416.0   822073.7  20992.0 19937.1 3072.0 2702.8     11    0.978   0      0.000    0.97813.7 34048.0 34048.0 34048.0  0.0   272640.0 211949.9 1756416.0   897364.4  21248.0 20179.6 3072.0 2728.1     12    1.087   1      0.004    1.09114.7 34048.0 34048.0  0.0   34047.1 272640.0 245801.5 1756416.0   597362.6  21504.0 20390.6 3072.0 2750.3     13    1.183   2      0.050    1.23315.7 34048.0 34048.0  0.0   34048.0 272640.0 21474.1  1756416.0   757347.0  22012.0 20792.0 3200.0 2791.0     15    1.336   2      0.050    1.38616.7 34048.0 34048.0 34047.0  0.0   272640.0 48378.0  1756416.0   838594.4  22268.0 21003.5 3200.0 2813.2     16    1.433   2      0.050    1.484</span><br></pre></td></tr></table></figure>
<p>这个片段是 JVM 启动后第17秒提取的。基于该信息，我们可以得出这样的结果，运行了12次 Minor GC、2次 Full GC，时间总跨度为50毫秒。通过 jconsole 或者 jvisualvm 这样的基于GUI的工具你能得到同样的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 java -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC eu.plumbr.demo.GarbageProducer</span><br><span class="line">12345678910111213141516171819 3.157: [GC (Allocation Failure) 3.157: [ParNew: 272640K-&gt;34048K(306688K), 0.0844702 secs] 272640K-&gt;69574K(2063104K), 0.0845560 secs] [Times: user=0.23 sys=0.03, real=0.09 secs] 4.092: [GC (Allocation Failure) 4.092: [ParNew: 306688K-&gt;34048K(306688K), 0.1013723 secs] 342214K-&gt;136584K(2063104K), 0.1014307 secs] [Times: user=0.25 sys=0.05, real=0.10 secs] ... cut for brevity ...11.292: [GC (Allocation Failure) 11.292: [ParNew: 306686K-&gt;34048K(306688K), 0.0857219 secs] 971599K-&gt;779148K(2063104K), 0.0857875 secs] [Times: user=0.26 sys=0.04, real=0.09 secs] 12.140: [GC (Allocation Failure) 12.140: [ParNew: 306688K-&gt;34046K(306688K), 0.0821774 secs] 1051788K-&gt;856120K(2063104K), 0.0822400 secs] [Times: user=0.25 sys=0.03, real=0.08 secs] 12.989: [GC (Allocation Failure) 12.989: [ParNew: 306686K-&gt;34048K(306688K), 0.1086667 secs] 1128760K-&gt;931412K(2063104K), 0.1087416 secs] [Times: user=0.24 sys=0.04, real=0.11 secs] 13.098: [GC (CMS Initial Mark) [1 CMS-initial-mark: 897364K(1756416K)] 936667K(2063104K), 0.0041705 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] 13.102: [CMS-concurrent-mark-start]13.341: [CMS-concurrent-mark: 0.238/0.238 secs] [Times: user=0.36 sys=0.01, real=0.24 secs] 13.341: [CMS-concurrent-preclean-start]13.350: [CMS-concurrent-preclean: 0.009/0.009 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] 13.350: [CMS-concurrent-abortable-preclean-start]13.878: [GC (Allocation Failure) 13.878: [ParNew: 306688K-&gt;34047K(306688K), 0.0960456 secs] 1204052K-&gt;1010638K(2063104K), 0.0961542 secs] [Times: user=0.29 sys=0.04, real=0.09 secs] 14.366: [CMS-concurrent-abortable-preclean: 0.917/1.016 secs] [Times: user=2.22 sys=0.07, real=1.01 secs] 14.366: [GC (CMS Final Remark) [YG occupancy: 182593 K (306688 K)]14.366: [Rescan (parallel) , 0.0291598 secs]14.395: [weak refs processing, 0.0000232 secs]14.395: [class unloading, 0.0117661 secs]14.407: [scrub symbol table, 0.0015323 secs]14.409: [scrub string table, 0.0003221 secs][1 CMS-remark: 976591K(1756416K)] 1159184K(2063104K), 0.0462010 secs] [Times: user=0.14 sys=0.00, real=0.05 secs] 14.412: [CMS-concurrent-sweep-start]14.633: [CMS-concurrent-sweep: 0.221/0.221 secs] [Times: user=0.37 sys=0.00, real=0.22 secs] 14.633: [CMS-concurrent-reset-start]14.636: [CMS-concurrent-reset: 0.002/0.002 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure>
<p>在点头同意这个结论之前，让我们看看来自同一个 JVM 启动收集的垃圾收集日志的输出。显然- XX ： + PrintGCDetails 告诉我们一个不同且更详细的故事：</p>
<p>基于这些信息，我们可以看到12次 Minor GC 后开始有些和上面不一样了。没有运行两次 Full GC，这不同的地方在于单个 GC 在永久代中不同阶段运行了两次：</p>
<p>最初的标记阶段，用了0.0041705秒也就是4ms左右。这个阶段会暂停“全世界（ stop-the-world）”的事件，停止所有应用程序的线程，然后开始标记。<br>并行执行标记和清洗阶段。这些都是和应用程序线程并行的。<br>最后 Remark 阶段，花费了0.0462010秒约46ms。这个阶段会再次暂停所有的事件。<br>并行执行清理操作。</p>
<p>正如其名，此阶段也是并行的，不会停止其他线程。<br>所以，正如我们从垃圾回收日志中所看到的那样，实际上只是执行了 Major GC 去清理老年代空间而已，而不是执行了两次 Full GC。<br>如果你是后期做决 定的话，那么由 jstat 提供的数据会引导你做出正确的决策。它正确列出的两个暂停所有事件的情况，导致所有线程停止了共计50ms。但是如果你试图优化吞吐量，你会被误导的。清 单只列出了回收初始标记和最终 Remark 阶段，jstat的输出看不到那些并发完成的工作。</p>
<p>结论<br>考虑到这种情况，最好避免以 Minor、Major、Full GC 这种方式来思考问题。而应该监控应用延迟或者吞吐量，然后将 GC 事件和结果联系起来。<br>随着这些 GC 事件的发生，你需要额外的关注某些信息，GC 事件是强制所有应用程序线程停止了还是并行的处理了部分事件。</p>
]]></content>
      <categories>
        <category>Jvm虚拟机</category>
      </categories>
  </entry>
</search>
